# Импорт библиотек для работы со временем, асинхронностью и HTTP запросами
import time  
import asyncio  
import requests  
import aiohttp  



# Список реальных ссылок на изображения и файлы с разных источников
# Эти ссылки используются для демонстрации разницы между синхронным и асинхронным скачиванием
URLS = [
    "https://www.w3schools.com/html/pic_trulli.jpg",  # W3Schools - изображение
    "https://httpbin.org/image/jpeg",  # httpbin.org - синтетическое JPEG
    "https://httpbin.org/image/png",  # httpbin.org - синтетическое PNG
    "https://upload.wikimedia.org/wikipedia/commons/3/3a/Cat03.jpg",  # Wikimedia - кот JPEG
    "https://httpbin.org/delay/1",  # httpbin.org - задержка 1 сек (для демо)
    "https://jsonplaceholder.typicode.com/photos/1",  # JSONPlaceholder - мок данные
    "https://httpbin.org/status/200",  # httpbin.org - проверка статуса
    "https://raw.githubusercontent.com/github/gitignore/master/Python.gitignore",  # GitHub - текстовый файл
]



# СИНХРОННОЕ СКАЧИВАНИЕ (последовательное, блокирующее)


def download_sync(url):
    """
    Синхронная функция для скачивания файла по URL.
    
    Аргументы:
        url (str): URL адрес для скачивания
    
    Возвращает:
        int: HTTP статус код ответа (200 - успех, 404 - не найдено, 0 - ошибка соединения)
    """
    try:
        # Получаем ответ с таймаутом 10 секунд (предотвращает бесконечное ожидание)
        response = requests.get(url, timeout=10)
        return response.status_code
    except requests.exceptions.RequestException as e:
        # Обрабатываем любые ошибки (timeout, connection error, etc)
        print(f"⚠️  Ошибка при скачивании {url}: {type(e).__name__}")
        return 0  # Возвращаем 0 как код ошибки


def run_sync():
    """
    Запускает синхронное скачивание всех URL'ов последовательно.
    
    Процесс:
    1. Запускаем таймер
    2. Для каждого URL вызываем download_sync()
    3. Каждый запрос блокирует выполнение программы до завершения
    4. Только после завершения первого запроса начинается второй
    
    Возвращает:
        float: Время выполнения в секундах
    """
    start = time.perf_counter()  # Начало отсчета времени

    # Последовательный цикл - один запрос за другим
    for url in URLS:
        download_sync(url)  # Блокирующий вызов - ждем ответа

    # Вычисляем прошедшее время
    return time.perf_counter() - start



# АСИНХРОННОЕ СКАЧИВАНИЕ (параллельное, неблокирующее)


async def download_async(session, url):
    """
    Асинхронная функция для скачивания файла по URL.
    
    Аргументы:
        session (aiohttp.ClientSession): Асинхронная сессия для переиспользования соединения
        url (str): URL адрес для скачивания
    
    Возвращает:
        int: HTTP статус код ответа (200 - успех, 0 - ошибка)
    
    Особенность:
        - Использует 'async with' для неблокирующего скачивания
        - Освобождает управление, пока ждет ответ сервера
        - Позволяет другим задачам выполняться параллельно
        - Обработка ошибок предотвращает падение программы
    """
    try:
        # timeout=10 предотвращает бесконечное ожидание
        async with session.get(url, timeout=aiohttp.ClientTimeout(total=10)) as response:
            return response.status
    except asyncio.TimeoutError:
        # Таймаут - сервер не ответил вовремя
        print(f"Таймаут при скачивании {url}")
        return 0
    except aiohttp.ClientError as e:
        # Ошибка соединения, DNS и т.д.
        print(f"Ошибка при скачивании {url}: {type(e).__name__}")
        return 0
    except Exception as e:
        # Все остальные ошибки
        print(f"Неожиданная ошибка при скачивании {url}: {type(e).__name__}")
        return 0


async def run_async():
    """
    Запускает асинхронное скачивание всех URL'ов параллельно.
    
    Процесс:
    1. Создаем асинхронную сессию (переиспользует TCP соединения - экономит ресурсы)
    2. Создаем список задач (tasks) - все скачивания готовы к запуску
    3. asyncio.gather() запускает ВСЕ задачи одновременно
    4. Пока идет скачивание от одного сервера, программа может ждать ответа от других
    
    Возвращает:
        float: Время выполнения в секундах
    
    Примечание:
        При большом количестве URL'ов все скачивания идут 'параллельно' (конкурентно)
    """
    start = time.perf_counter()  # Начало отсчета времени

    # ClientSession() - создает одно переиспользуемое соединение для экономии ресурсов
    async with aiohttp.ClientSession() as session:
        # Создаем список асинхронных задач (coroutines)
        # На этом этапе они ЕЩЕ НЕ ЗАПУЩЕНЫ, только подготовлены
        tasks = [download_async(session, url) for url in URLS]
        
        # asyncio.gather() запускает ВСЕ задачи одновременно и ждет завершения ВСЕХ
        # Это главная фишка асинхронности - параллельное выполнение
        await asyncio.gather(*tasks)

    # Вычисляем прошедшее время
    return time.perf_counter() - start




if __name__ == "__main__":
    # ================================================================
    # ЗАПУСК ТЕСТОВ ПРОИЗВОДИТЕЛЬНОСТИ
    # ================================================================
    
    # Списки для сохранения результатов измерений
    sync_times = []  # Времена синхронного скачивания
    async_times = []  # Времена асинхронного скачивания

    # ТЕСТ 1: Синхронное скачивание (последовательное)
    print("ТЕСТ 1: СИНХРОННОЕ СКАЧИВАНИЕ (последовательное)")
    print("Принцип: Один запрос за другим. Ждем окончания, потом начинаем следующий.")
    print()
    
    for i in range(3):
        # Каждый вызов run_sync() скачивает все URL'ы последовательно
        t = run_sync()
        sync_times.append(t)
        print(f"  Замер {i+1}: {t:.2f} сек")

    # ТЕСТ 2: Асинхронное скачивание (параллельное)
    print("\nТЕСТ 2: АСИНХРОННОЕ СКАЧИВАНИЕ (параллельное)")
    print("Принцип: Все запросы идут одновременно. Пока один сервер обрабатывает,")
    print("         программа уже отправила запросы другим серверам.")
    print()
    
    for i in range(3):
        # asyncio.run() запускает асинхронную функцию в новом event loop
        t = asyncio.run(run_async())
        async_times.append(t)
        print(f"  Замер {i+1}: {t:.2f} сек")

    # Вычисление средних значений для более точного сравнения
    avg_sync = sum(sync_times) / len(sync_times)
    avg_async = sum(async_times) / len(async_times)

    # Вывод итоговых результатов
    print("\nИТОГОВЫЕ РЕЗУЛЬТАТЫ")
    print(f"  Синхронно  (среднее):  {avg_sync:.2f} сек")
    print(f"  Асинхронно (среднее):  {avg_async:.2f} сек")
    
    # Вычисление ускорения
    speedup = avg_sync / avg_async
    print(f"  Ускорение:             {speedup:.2f}x быстрее")
    print()

    # ЗАПИСЬ РЕЗУЛЬТАТОВ В ФАЙЛ С ПОДРОБНЫМИ ОБЪЯСНЕНИЯМИ
    
    with open("results.txt", "w", encoding="utf-8") as f:
        # Заголовок
        f.write("СРАВНЕНИЕ СИНХРОННОГО И АСИНХРОННОГО СКАЧИВАНИЯ\n\n")

        # Детальные результаты синхронного скачивания
        f.write("СИНХРОННЫЕ ЗАМЕРЫ (последовательное скачивание)\n")
        for i, t in enumerate(sync_times, 1):
            f.write(f"  Замер {i}: {t:.4f} сек\n")
        f.write(f"  Среднее (sync): {avg_sync:.4f} сек\n")
        f.write(f"  Минимум: {min(sync_times):.4f} сек\n")
        f.write(f"  Максимум: {max(sync_times):.4f} сек\n\n")


        f.write("АСИНХРОННЫЕ ЗАМЕРЫ (параллельное скачивание)\n")
        for i, t in enumerate(async_times, 1):
            f.write(f"  Замер {i}: {t:.4f} сек\n")
        f.write(f"  Среднее (async): {avg_async:.4f} сек\n")
        f.write(f"  Минимум: {min(async_times):.4f} сек\n")
        f.write(f"  Максимум: {max(async_times):.4f} сек\n\n")

        # Анализ результатов
        f.write("\nАНАЛИЗ И ОБЪЯСНЕНИЕ РЕЗУЛЬТАТОВ\n\n")

        f.write("ПОЧЕМУ АСИНХРОННОЕ СКАЧИВАНИЕ БЫСТРЕЕ?\n\n")

        f.write("1. СИНХРОННЫЙ ПОДХОД (Последовательно)\n")
        f.write("   1. Отправляем запрос на сервер №1\n")
        f.write("   2. ЖДЕМ ответа от сервера №1 (программа заморожена)\n")
        f.write("   3. Получили ответ, отправляем запрос на сервер №2\n")
        f.write("   4. ЖДЕМ ответа от сервера №2 (программа заморожена)\n")
        f.write("   5. И так далее...\n")
        f.write(f"   ИТОГО ВРЕМЯ: примерно 8 × (время одного запроса) = ~{avg_sync:.1f} сек\n\n")

        f.write("2. АСИНХРОННЫЙ ПОДХОД (Параллельно)\n")
        f.write("   1. Отправляем запрос на сервер №1\n")
        f.write("   2. Тут же отправляем запрос на сервер №2\n")
        f.write("   3. Тут же отправляем запрос на сервер №3\n")
        f.write("   4. ... отправляем запросы на ВСЕ серверы\n")
        f.write("   5. ЖДЕМ ответа от ВСЕХ серверов ОДНОВРЕМЕННО\n")
        f.write("   6. Когда самый медленный сервер ответит - готово!\n")
        f.write(f"   ИТОГО ВРЕМЯ: примерно 1 × (время самого медленного запроса) = ~{avg_async:.1f} сек\n\n")

        f.write("3. КЛЮЧЕВОЕ РАЗЛИЧИЕ\n")
        f.write("   СИНХРОННО: Получаем ответ №1 → ПОТОМ отправляем запрос №2\n")
        f.write("             Фронт-процесс ЖДЕТ (блокирущее ожидание)\n\n")
        
        f.write("   АСИНХРОННО: Отправляем ВСЕ запросы → ПОТОМ ждем ответов\n")
        f.write("              Пока ждем от сервера №1, мы уже общаемся с другими\n")
        f.write("              Программа НИКОГДА не замирает\n\n")

        f.write("4. АНАЛОГИЯ ИЗ ЖИЗНИ\n")
        f.write("   СИНХРОННО:")
        f.write("\n   Кассир обслуживает клиентов очередью:\n")
        f.write("   - Обслужил клиента №1 (5 минут) → тот ушел\n")
        f.write("   - Обслужил клиента №2 (3 минуты) → тот ушел\n")
        f.write("   - Обслужил клиента №3 (7 минут) → тот ушел\n")
        f.write("   Итого: 5 + 3 + 7 = 15 минут\n\n")

        f.write("   АСИНХРОННО:\n")
        f.write("   8 кассиров работают параллельно, каждый со своим клиентом:\n")
        f.write("   - Кассир №1 обслуживает 5 минут\n")
        f.write("   - Кассир №2 обслуживает 3 минуты\n")
        f.write("   - Кассир №3 обслуживает 7 минут\n")
        f.write("   Итого: max(5, 3, 7) = 7 минут (время самого долгого!)\n\n")

        f.write("5. ФОРМУЛА УСКОРЕНИЯ\n")
        f.write(f"   Ускорение = Время синхронного / Время асинхронного\n")
        f.write(f"   Ускорение = {avg_sync:.2f} / {avg_async:.2f} = {speedup:.2f}x\n\n")
        f.write(f"   Это означает, что асинхронный способ в {speedup:.1f} раз БЫСТРЕЕ!\n\n")

        f.write("6. КОГДА ИСПОЛЬЗОВАТЬ АСИНХРОННОСТЬ?\n")
        f.write("   - Много сетевых запросов (API, базы данных, скачивание файлов)\n")
        f.write("   - I/O операции (чтение с диска, работа с интернетом)\n")
        f.write("   - Когда много операций, которые ждут ответов\n\n")
        f.write("   - НЕ нужна асинхронность для тяжелых вычислений (CPU bound)\n")
        f.write("   - НЕ нужна асинхронность для простых операций\n\n")

        f.write("ВЫВОД: Асинхронное программирование экономит ВРЕМЯ ОЖИДАНИЯ!\n")

    # Вывод подтверждения в консоль
    print("Результаты записаны в файл 'results.txt'")
    print("\nРекомендация: Откройте results.txt для подробного анализа!")

